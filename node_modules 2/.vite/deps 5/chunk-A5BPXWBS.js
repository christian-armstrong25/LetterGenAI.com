import {
  PromptTemplate
} from "./chunk-5XDZWGDB.js";
import {
  BasePromptTemplate
} from "./chunk-2H5UPX2F.js";
import {
  AIChatMessage,
  BasePromptValue,
  ChatMessage,
  HumanChatMessage,
  SystemChatMessage
} from "./chunk-GRBVEDV4.js";

// node_modules/langchain/dist/prompts/chat.js
var BaseMessagePromptTemplate = class {
  serialize() {
    return {
      _type: this.constructor.name,
      ...JSON.parse(JSON.stringify(this))
    };
  }
};
var ChatPromptValue = class extends BasePromptValue {
  constructor(messages) {
    super();
    Object.defineProperty(this, "messages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.messages = messages;
  }
  toString() {
    return JSON.stringify(this.messages);
  }
  toChatMessages() {
    return this.messages;
  }
};
var MessagesPlaceholder = class extends BaseMessagePromptTemplate {
  constructor(variableName) {
    super();
    Object.defineProperty(this, "variableName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.variableName = variableName;
  }
  get inputVariables() {
    return [this.variableName];
  }
  formatMessages(values) {
    return Promise.resolve(values[this.variableName]);
  }
};
var BaseMessageStringPromptTemplate = class extends BaseMessagePromptTemplate {
  constructor(prompt) {
    super();
    Object.defineProperty(this, "prompt", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.prompt = prompt;
  }
  get inputVariables() {
    return this.prompt.inputVariables;
  }
  async formatMessages(values) {
    return [await this.format(values)];
  }
};
var BaseChatPromptTemplate = class extends BasePromptTemplate {
  constructor(input) {
    super(input);
  }
  async format(values) {
    return (await this.formatPromptValue(values)).toString();
  }
  async formatPromptValue(values) {
    const resultMessages = await this.formatMessages(values);
    return new ChatPromptValue(resultMessages);
  }
};
var ChatMessagePromptTemplate = class extends BaseMessageStringPromptTemplate {
  async format(values) {
    return new ChatMessage(await this.prompt.format(values), this.role);
  }
  constructor(prompt, role) {
    super(prompt);
    Object.defineProperty(this, "role", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.role = role;
  }
  static fromTemplate(template, role) {
    return new this(PromptTemplate.fromTemplate(template), role);
  }
};
var HumanMessagePromptTemplate = class extends BaseMessageStringPromptTemplate {
  async format(values) {
    return new HumanChatMessage(await this.prompt.format(values));
  }
  constructor(prompt) {
    super(prompt);
  }
  static fromTemplate(template) {
    return new this(PromptTemplate.fromTemplate(template));
  }
};
var AIMessagePromptTemplate = class extends BaseMessageStringPromptTemplate {
  async format(values) {
    return new AIChatMessage(await this.prompt.format(values));
  }
  constructor(prompt) {
    super(prompt);
  }
  static fromTemplate(template) {
    return new this(PromptTemplate.fromTemplate(template));
  }
};
var SystemMessagePromptTemplate = class extends BaseMessageStringPromptTemplate {
  async format(values) {
    return new SystemChatMessage(await this.prompt.format(values));
  }
  constructor(prompt) {
    super(prompt);
  }
  static fromTemplate(template) {
    return new this(PromptTemplate.fromTemplate(template));
  }
};
var ChatPromptTemplate = class extends BaseChatPromptTemplate {
  constructor(input) {
    super(input);
    Object.defineProperty(this, "promptMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "validateTemplate", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.assign(this, input);
    if (this.validateTemplate) {
      const inputVariablesMessages = /* @__PURE__ */ new Set();
      for (const promptMessage of this.promptMessages) {
        for (const inputVariable of promptMessage.inputVariables) {
          inputVariablesMessages.add(inputVariable);
        }
      }
      const inputVariablesInstance = new Set(this.partialVariables ? this.inputVariables.concat(Object.keys(this.partialVariables)) : this.inputVariables);
      const difference = new Set([...inputVariablesInstance].filter((x) => !inputVariablesMessages.has(x)));
      if (difference.size > 0) {
        throw new Error(`Input variables \`${[
          ...difference
        ]}\` are not used in any of the prompt messages.`);
      }
      const otherDifference = new Set([...inputVariablesMessages].filter((x) => !inputVariablesInstance.has(x)));
      if (otherDifference.size > 0) {
        throw new Error(`Input variables \`${[
          ...otherDifference
        ]}\` are used in prompt messages but not in the prompt template.`);
      }
    }
  }
  _getPromptType() {
    return "chat";
  }
  async formatMessages(values) {
    const allValues = await this.mergePartialAndUserVariables(values);
    let resultMessages = [];
    for (const promptMessage of this.promptMessages) {
      const inputValues = promptMessage.inputVariables.reduce((acc, inputVariable) => {
        if (!(inputVariable in allValues)) {
          throw new Error(`Missing value for input variable \`${inputVariable}\``);
        }
        acc[inputVariable] = allValues[inputVariable];
        return acc;
      }, {});
      const message = await promptMessage.formatMessages(inputValues);
      resultMessages = resultMessages.concat(message);
    }
    return resultMessages;
  }
  serialize() {
    if (this.outputParser !== void 0) {
      throw new Error("ChatPromptTemplate cannot be serialized if outputParser is set");
    }
    return {
      input_variables: this.inputVariables,
      prompt_messages: this.promptMessages.map((m) => m.serialize())
    };
  }
  async partial(values) {
    const promptDict = { ...this };
    promptDict.inputVariables = this.inputVariables.filter((iv) => !(iv in values));
    promptDict.partialVariables = {
      ...this.partialVariables ?? {},
      ...values
    };
    return new ChatPromptTemplate(promptDict);
  }
  static fromPromptMessages(promptMessages) {
    const flattenedMessages = promptMessages.reduce((acc, promptMessage) => acc.concat(
      // eslint-disable-next-line no-instanceof/no-instanceof
      promptMessage instanceof ChatPromptTemplate ? promptMessage.promptMessages : [promptMessage]
    ), []);
    const flattenedPartialVariables = promptMessages.reduce((acc, promptMessage) => (
      // eslint-disable-next-line no-instanceof/no-instanceof
      promptMessage instanceof ChatPromptTemplate ? Object.assign(acc, promptMessage.partialVariables) : acc
    ), /* @__PURE__ */ Object.create(null));
    const inputVariables = /* @__PURE__ */ new Set();
    for (const promptMessage of flattenedMessages) {
      for (const inputVariable of promptMessage.inputVariables) {
        if (inputVariable in flattenedPartialVariables) {
          continue;
        }
        inputVariables.add(inputVariable);
      }
    }
    return new ChatPromptTemplate({
      inputVariables: [...inputVariables],
      promptMessages: flattenedMessages,
      partialVariables: flattenedPartialVariables
    });
  }
};

// node_modules/langchain/dist/prompts/selectors/conditional.js
var BasePromptSelector = class {
  async getPromptAsync(llm, options) {
    const prompt = this.getPrompt(llm);
    return prompt.partial((options == null ? void 0 : options.partialVariables) ?? {});
  }
};
var ConditionalPromptSelector = class extends BasePromptSelector {
  constructor(default_prompt, conditionals = []) {
    super();
    Object.defineProperty(this, "defaultPrompt", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "conditionals", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.defaultPrompt = default_prompt;
    this.conditionals = conditionals;
  }
  getPrompt(llm) {
    for (const [condition, prompt] of this.conditionals) {
      if (condition(llm)) {
        return prompt;
      }
    }
    return this.defaultPrompt;
  }
};
function isLLM(llm) {
  return llm._modelType() === "base_llm";
}
function isChatModel(llm) {
  return llm._modelType() === "base_chat_model";
}

// node_modules/langchain/dist/prompts/selectors/LengthBasedExampleSelector.js
function getLengthBased(text) {
  return text.split(/\n| /).length;
}
var LengthBasedExampleSelector = class {
  constructor(data) {
    Object.defineProperty(this, "examples", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "examplePrompt", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "getTextLength", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: getLengthBased
    });
    Object.defineProperty(this, "maxLength", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 2048
    });
    Object.defineProperty(this, "exampleTextLengths", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    this.examplePrompt = data.examplePrompt;
    this.maxLength = data.maxLength ?? 2048;
    this.getTextLength = data.getTextLength ?? getLengthBased;
  }
  async addExample(example) {
    this.examples.push(example);
    const stringExample = await this.examplePrompt.format(example);
    this.exampleTextLengths.push(this.getTextLength(stringExample));
  }
  async calculateExampleTextLengths(v, values) {
    if (v.length > 0) {
      return v;
    }
    const { examples, examplePrompt } = values;
    const stringExamples = await Promise.all(examples.map((eg) => examplePrompt.format(eg)));
    return stringExamples.map((eg) => this.getTextLength(eg));
  }
  async selectExamples(inputVariables) {
    const inputs = Object.values(inputVariables).join(" ");
    let remainingLength = this.maxLength - this.getTextLength(inputs);
    let i = 0;
    const examples = [];
    while (remainingLength > 0 && i < this.examples.length) {
      const newLength = remainingLength - this.exampleTextLengths[i];
      if (newLength < 0) {
        break;
      } else {
        examples.push(this.examples[i]);
        remainingLength = newLength;
      }
      i += 1;
    }
    return examples;
  }
  static async fromExamples(examples, args) {
    const selector = new LengthBasedExampleSelector(args);
    await Promise.all(examples.map((eg) => selector.addExample(eg)));
    return selector;
  }
};

// node_modules/langchain/dist/document.js
var Document = class {
  constructor(fields) {
    Object.defineProperty(this, "pageContent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.pageContent = fields.pageContent ? fields.pageContent.toString() : this.pageContent;
    this.metadata = fields.metadata ?? {};
  }
};

// node_modules/langchain/dist/prompts/selectors/SemanticSimilarityExampleSelector.js
function sortedValues(values) {
  return Object.keys(values).sort().map((key) => values[key]);
}
var SemanticSimilarityExampleSelector = class {
  constructor(data) {
    Object.defineProperty(this, "vectorStore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "k", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4
    });
    Object.defineProperty(this, "exampleKeys", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "inputKeys", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.vectorStore = data.vectorStore;
    this.k = data.k ?? 4;
    this.exampleKeys = data.exampleKeys;
    this.inputKeys = data.inputKeys;
  }
  async addExample(example) {
    const inputKeys = this.inputKeys ?? Object.keys(example);
    const stringExample = sortedValues(inputKeys.reduce((acc, key) => ({ ...acc, [key]: example[key] }), {})).join(" ");
    await this.vectorStore.addDocuments([
      new Document({
        pageContent: stringExample,
        metadata: { example }
      })
    ]);
  }
  async selectExamples(inputVariables) {
    const inputKeys = this.inputKeys ?? Object.keys(inputVariables);
    const query = sortedValues(inputKeys.reduce((acc, key) => ({ ...acc, [key]: inputVariables[key] }), {})).join(" ");
    const exampleDocs = await this.vectorStore.similaritySearch(query, this.k);
    const examples = exampleDocs.map((doc) => doc.metadata);
    if (this.exampleKeys) {
      return examples.map((example) => this.exampleKeys.reduce((acc, key) => ({ ...acc, [key]: example[key] }), {}));
    }
    return examples;
  }
  static async fromExamples(examples, embeddings, vectorStoreCls, options = {}) {
    const inputKeys = options.inputKeys ?? null;
    const stringExamples = examples.map((example) => sortedValues(inputKeys ? inputKeys.reduce((acc, key) => ({ ...acc, [key]: example[key] }), {}) : example).join(" "));
    const vectorStore = await vectorStoreCls.fromTexts(
      stringExamples,
      examples,
      // metadatas
      embeddings,
      options
    );
    return new SemanticSimilarityExampleSelector({
      vectorStore,
      k: options.k ?? 4,
      exampleKeys: options.exampleKeys,
      inputKeys: options.inputKeys
    });
  }
};

// node_modules/langchain/dist/prompts/pipeline.js
var PipelinePromptTemplate = class extends BasePromptTemplate {
  constructor(input) {
    super({ ...input, inputVariables: [] });
    Object.defineProperty(this, "pipelinePrompts", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "finalPrompt", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.pipelinePrompts = input.pipelinePrompts;
    this.finalPrompt = input.finalPrompt;
    this.inputVariables = this.computeInputValues();
  }
  computeInputValues() {
    const intermediateValues = this.pipelinePrompts.map((pipelinePrompt) => pipelinePrompt.name);
    const inputValues = this.pipelinePrompts.map((pipelinePrompt) => pipelinePrompt.prompt.inputVariables.filter((inputValue) => !intermediateValues.includes(inputValue))).flat();
    return [...new Set(inputValues)];
  }
  static extractRequiredInputValues(allValues, requiredValueNames) {
    return requiredValueNames.reduce((requiredValues, valueName) => {
      requiredValues[valueName] = allValues[valueName];
      return requiredValues;
    }, {});
  }
  async formatPipelinePrompts(values) {
    const allValues = await this.mergePartialAndUserVariables(values);
    for (const { name: pipelinePromptName, prompt: pipelinePrompt } of this.pipelinePrompts) {
      const pipelinePromptInputValues = PipelinePromptTemplate.extractRequiredInputValues(allValues, pipelinePrompt.inputVariables);
      if (pipelinePrompt instanceof ChatPromptTemplate) {
        allValues[pipelinePromptName] = await pipelinePrompt.formatMessages(pipelinePromptInputValues);
      } else {
        allValues[pipelinePromptName] = await pipelinePrompt.format(pipelinePromptInputValues);
      }
    }
    return PipelinePromptTemplate.extractRequiredInputValues(allValues, this.finalPrompt.inputVariables);
  }
  async formatPromptValue(values) {
    return this.finalPrompt.formatPromptValue(await this.formatPipelinePrompts(values));
  }
  async format(values) {
    return this.finalPrompt.format(await this.formatPipelinePrompts(values));
  }
  async partial(values) {
    const promptDict = { ...this };
    promptDict.inputVariables = this.inputVariables.filter((iv) => !(iv in values));
    promptDict.partialVariables = {
      ...this.partialVariables ?? {},
      ...values
    };
    return new PipelinePromptTemplate(promptDict);
  }
  serialize() {
    throw new Error("Not implemented.");
  }
  _getPromptType() {
    return "pipeline";
  }
};

export {
  MessagesPlaceholder,
  BaseChatPromptTemplate,
  ChatMessagePromptTemplate,
  HumanMessagePromptTemplate,
  AIMessagePromptTemplate,
  SystemMessagePromptTemplate,
  ChatPromptTemplate,
  BasePromptSelector,
  ConditionalPromptSelector,
  isLLM,
  isChatModel,
  LengthBasedExampleSelector,
  Document,
  SemanticSimilarityExampleSelector,
  PipelinePromptTemplate
};
//# sourceMappingURL=chunk-A5BPXWBS.js.map
